% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/KorAPConnection.R
\docType{class}
\name{KorAPConnection-class}
\alias{KorAPConnection-class}
\alias{KorAPConnection}
\alias{initialize,KorAPConnection-method}
\alias{persistAccessToken,KorAPConnection-method}
\alias{persistAccessToken}
\alias{clearAccessToken,KorAPConnection-method}
\alias{clearAccessToken}
\alias{apiCall,KorAPConnection-method}
\alias{apiCall}
\alias{clearCache,KorAPConnection-method}
\alias{clearCache}
\alias{show,KorAPConnection-method}
\title{Class KorAPConnection}
\usage{
\S4method{initialize}{KorAPConnection}(
  .Object,
  KorAPUrl = "https://korap.ids-mannheim.de/",
  apiVersion = "v1.0",
  apiUrl,
  accessToken = getAccessToken(KorAPUrl),
  userAgent = "R-KorAP-Client",
  timeout = 110,
  verbose = FALSE,
  cache = TRUE
)

\S4method{persistAccessToken}{KorAPConnection}(kco, accessToken = kco@accessToken)

\S4method{clearAccessToken}{KorAPConnection}(kco)

\S4method{apiCall}{KorAPConnection}(kco, url, json = TRUE, getHeaders = FALSE, cache = kco@cache)

\S4method{clearCache}{KorAPConnection}(kco)

\S4method{show}{KorAPConnection}(object)
}
\arguments{
\item{.Object}{KorAPConnection object}

\item{KorAPUrl}{the URL of the KorAP server instance you want to access.}

\item{apiVersion}{which version of KorAP's API you want to connect to.}

\item{apiUrl}{URL of the KorAP web service.}

\item{accessToken}{OAuth2 access token. To use authorization based on an access token
in subsequent queries, initialize your KorAP connection with
\code{kco <- new("KorAPConnection", accessToken="<access token>")}.
In order to make the API
token persistent for the currently used \code{KorAPUrl} (you can have one
token per KorAPUrl / KorAP server instance), use
\code{persistAccessToken(kco)}. This will store it in your keyring using the
\code{\link{keyring}} package. Subsequent new("KorAPConnection") calls will
then automatically retrieve the token from your keying. To stop using a
persisted token, call \code{clearAccessToken(kco)}. Please note that for
DeReKo, authorized queries will behave differently inside and outside the
IDS, because of the special license situation. This concerns also cached
results which do not take into account from where a request was issued. If
you experience problems or unexpected results, please try \code{kco <-
new("KorAPConnection", cache=FALSE)} or use
\code{\link{clearCache}} to clear the cache completely.}

\item{userAgent}{user agent string.}

\item{timeout}{time out in seconds.}

\item{verbose}{logical. Decides whether following operations will default to
be verbose.}

\item{cache}{logical. Decides if API calls are cached locally. You can clear
the cache with \code{\link{clearCache}()}.}

\item{kco}{KorAPConnection object}

\item{url}{request url}

\item{json}{logical that determines if json result is expected}

\item{getHeaders}{logical that determines if headers and content should be returned (as a list)}

\item{object}{KorAPConnection object}
}
\value{
\code{\link{KorAPConnection}} object that can be used e.g. with
  \code{\link{corpusQuery}}
}
\description{
\code{KorAPConnection} objects represent the connection to a KorAP server.
New \code{KorAPConnection} objects can be created by \code{new("KorAPConnection")}.
}
\examples{
\donttest{
kcon <- new("KorAPConnection", verbose = TRUE)
kq <- corpusQuery(kcon, "Ameisenplage")
kq <- fetchAll(kq)
}

\dontrun{
kcon <- new("KorAPConnection", verbose = TRUE, accessToken="e739u6eOzkwADQPdVChxFg")
kq <- corpusQuery(kcon, "Ameisenplage", metadataOnly=FALSE)
kq <- fetchAll(kq)
kq@collectedMatches$snippet
}

\dontrun{
kco <- new("KorAPConnection", accessToken="e739u6eOzkwADQPdVChxFg")
persistAccessToken(kco)
}

\dontrun{
kco <- new("KorAPConnection")
clearAccessToken(kco)
}

}
